import numpy as np
import math

def calc_velocity_dynamics(calc_pars, model_pars, regul_pars):
    vtrace = [ np.array([calc_pars['t0'], calc_pars['v0']]) ];
    vSteps = [];
    vSteps.append(calc_pars['v0']);
    errs = [];
    errsSum = [];
    up = 0;
    uL = 0;
    sum = 0;
    u = 0;
    nls = 0;
    ts = [];
    ts.append(calc_pars['t0']);
    nsteps = calc_pars['tmax']/calc_pars['dt'];
    nsteps = math.floor(nsteps);

    #Заполняем массив с временем на каждом шаге
    for time in range(nsteps):
      if time <= calc_pars['tmax']:
        value = ts[time] + calc_pars['dt'];
      ts.append(value + 0.00);

    for step in range(nsteps):
      sum = 0;
      dV = 0;
      error = regul_pars['Vdir'] - vSteps[step];
      errs.append(error);

      #Вычисляем количество иттераций для подсчета еррор суммы
      if regul_pars['lag'] < step:
        nls = step - regul_pars['lag'];
      else:
        nls = 0;

      sum += error;
      for n in range(nls, step):
        sum += errs[n];

      up=regul_pars['kP']*error;
      uL=regul_pars['kI']*sum;

      u = up + uL;
      u = min(model_pars['Umax'], max(-model_pars['Umax'], u));
      dV = (u - model_pars['kc']*vSteps[step])*(calc_pars['dt']/model_pars['m']);
      vSteps.append(vSteps[step] + dV);

      vtrace.append(ts);
      vtrace.append(vSteps);

    return np.array(vtrace).T


def analys_tdone(vtrace, cruize_vel, v_precision):
  t_done = 0;
  vtrace_speeds = vtrace[2];
  for i in range(len(vtrace_speeds)):
    i = i + 1;
    if len(vtrace_speeds) >= i:
      if (vtrace_speeds[len(vtrace_speeds) - i] > cruize_vel + v_precision) or (vtrace_speeds[len(vtrace_speeds) - i] < cruize_vel - v_precision):
        return vtrace[1][len(vtrace_speeds) - i] + 1.00;
  return t_done